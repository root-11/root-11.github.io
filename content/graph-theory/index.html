<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../../style.css" rel="stylesheet" type="text/css">
    <title>grpah theory</title>
</head>
<body>
<br>
<div class = "center">
    <a href="../../index.html" style="text-decoration: none;"><b>BJORN MADSEN'S WEBSITE</b><br></a>
    <hr id="hrid"/>
    <div style="text-align: center; display: inline-block; width: 100%;">
        <a class="title" href="../../about.html">ABOUT</a> &nbsp;
        <a class="title" href="../../contact.html">EMAIL</a> &nbsp;
        <a class="title" href="https://paypal.me/BjornMadsen">DONATE</a>
    </div>
</div>
    <br><br>
    <div style="margin-bottom: 3ch;text-transform: none;"></div>

<div style="margin-bottom: 3ch;text-transform: none;">2020-05-31</div><div class="heading">graph theory</div><hr/>
<p><a href="https://pypi.org/project/graph-theory/">Graph theory</a> is a reference implementation
of all the algorithms I can find that have practical implications for solving problems
which can be modelled using nodes and edges. It has been in the works for a bit
over a year, and I'm quite happy with it's balance of simplicity, readability,
maintainability and its comprehensive interface.</p>
<p>The classes <code>BasicGraph</code>, <code>Graph</code> and <code>Graph3D</code>, doesn't quite cover everything 
on <a href="http://rosettacode.org/wiki/Rosetta_Code">RosettaCode.org</a> but I tend to 
follow it as well as time permits.</p>
<p>The remaining modules in graph-theory are present to support practical problem
solving. These include solvers for:</p>
<ul>
<li>the assignment problem (<code>from assignment_problem import ap_solver</code>)</li>
<li>the weapon-target assignment problem (<code>from assignment_problem import wtap_solver</code>)</li>
<li>any finite-state machine problem (<code>from finite_state_machine import FiniteStateMachine</code>)</li>
<li>three graph hashing problems (<code>from hash import graph_hash, flow_graph_hash, merkle_tree</code>) </li>
<li>randomised graph generation (<code>from graph.random import random_xy_graph</code>)</li>
</ul>
<p>The algorithms in these modules are inspired by problems faced in the field of 
logistics and supply chain management, where disruptive events are the norm: </p>
<blockquote>
<p>The perfect plan for the moment will have it's foundation
undermined by the next disruptive event.</p>
</blockquote>
<p>I believe my academic peers refer to this situation as a mixture of:</p>
<ol>
<li>The Online / Realtime problem, and </li>
<li>The maximum delayed commitment problem.</li>
</ol>
<p>I've tried to communicate the problem that follows when inputs change after 
computation has started, but few include that in their considerations. </p>
<p>So ever since I finished my Ph.D., I've taken the practical approach and simply
asked: "For the time it takes to solve this problem, does it matter if things change?"
If the answer is yes, then we need algorithms that are suitable for 
a <code>volatile environment</code>.</p>
<p>Such algorithms are characterised by:</p>
<ul>
<li>The have state </li>
<li>They co-evolve with changes. The don't "reset"</li>
<li>They have a minimal response time and take the initial conditions from 
the previous state. If the algorithms manage to find a better solution in the time
available, they simply switch from the solution recommended in the previous state.</li>
</ul>
<p>In plain english you can argue these algorithms are founded in the ideas of 
optimality rather than optimum: </p>
<blockquote>
<p>In a volative environment it's better to have a quick approximate solution, that
gets you in the right direction, rather than having to wait for the perfect plan.</p>
</blockquote>
<p>The goal with the additional modules is therefore to provide a guarantee that:
1. You can <code>yield</code> from the calculation at anytime and still get a reasonable 
good solution.
2. If you have enough time, you will get to the optimal solution.</p>
<p>Of the work I've done so far, I believe the implementations in <code>hash.flow_graph_hash</code>, 
<code>Graph.maximum_flow()</code> and the assignment problem solvers are either original 
or I have simply failed to discover references to elsewhere.</p>
<p>I also have solvers for the transshipment problem and a general purpose algorithm
for scheduling, but they still need a bit of work before I'm satisfied to release
them. Contact me if you want to know more about these.</p>

</body>
</html>
