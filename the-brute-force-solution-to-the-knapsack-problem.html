<html><head><style type="text/css">body {
  font-family: Monospace, /* Linux = DejaVu Sans Mono */
               Courier;   /* MacOSX & Windows = Courier */
  font-size: 16;
  max-width: 900px;  /* For Desktop PC (see @media for Tablets/Phones) */
  padding-left: 2%;
  padding-right: 3%;
  margin: 0 auto;
  background: #F5F5F0;
}



a {
  color: black;
  font-weight: bold;
}

img {
  border: none;
}

p {
  margin-top: 0px;
  margin-bottom: 4ch;
  text-align: justify;
}
sup {
  vertical-align: 0.3em;
  font-size: 0.65em;
}

pre {
  font-family: Monospace, /* Linux = DejaVu Sans Mono */
               Courier;   /* MacOSX & Windows = Courier */
  font-size: 16;
  background-color: white;
  border: 1px solid Black;
  padding-left: 2%;
  padding-top: 1ch;
  padding-bottom: 1ch;
  overflow: scroll;
}

div.heading {
  font-weight: bold;
  text-transform: uppercase;
}

/** {
  font-size: 16px;
}*/
@media (max-width: 500px) { /* For small screen decices */
  *{
    font-size: 12px;
  }
  pre {
   font-size: 11px;
  }
}
.title {
  text-decoration: none;
}

img.pixel, canvas.pixel {
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

blockquote {
background-color: #f3f3f3;
border: dashed 1px grey;
width: 97.5%;
font-style: italic;
text-align: justify;

padding: 1ch;
padding-top: 2ch;
padding-bottom: 2ch;

margin : 0ch;
margin-bottom: 2ch;
margin-top: 0ch;
}

blockquote div {
text-transform: none;
text-align: right;
width: 100%;
}</style><title>the brute force solution to the knapsack problem</title></head><body><br>
<center>

<div style="display: inline-block; vertical-align:middle;">

    <a href="index.html" style="text-decoration: none;"><b>BJORN MADSEN'S WEBSITE</b><br></a><hr/><div style="text-align: justify;display: inline-block; width: 100%;">
    <a class="title" href="about.html">ABOUT</a> &nbsp;
    <a class="title" href="contact.html">EMAIL</a> &nbsp;
    <a class="title" href="https://paypal.me/BjornMadsen">DONATE</a>
</div>
</div>
</center>
    <br>
    <br>
    <div style="margin-bottom: 3ch;text-transform: none;">
</div><div style="margin-bottom: 3ch;text-transform: none;">2020-05-12</div><div class="heading">the brute force solution to the knapsack problem</div><hr/><p>Computing the brute force solution is rarely the best way to go except when checking
other solvers. However as running the test suite can be time consuming, it's nice to 
have tools that run reasonably quickly.</p>
<p>The knapsack problem is an optimisation problem seeking to pack a container with the 
combination of items, so that the weight or volume constraints are respected and the
value of the items in the pack is maximised.</p>
<p>To test a solver for the knapsack problem it is helpful to generate all unique combinations
of items, so that the evalution is exhaustive. I will refer to this <code>set</code> as the 
<code>unique_powerset</code>. Here's an example:</p>
<pre><code>    unique_powerset([1,1,1,2,2,3]) --&gt; [
        (1,), (1, 1), (1, 1, 1), (2,), (2, 2), (3,),
        (1, 2), (1, 1, 2), (1, 1, 1, 2),
        (1, 2, 2), (1, 1, 2, 2), (1, 1, 1, 2, 2),
        (1, 3), (1, 1, 3), (1, 1, 1, 3),
        (2, 3), (2, 2, 3), (1, 2, 3),
        (1, 1, 2, 3), (1, 1, 1, 2, 3),
        (1, 2, 2, 3), (1, 1, 2, 2, 3),
        (1, 1, 1, 2, 2, 3)
    ] # 23 records
</code></pre>
<p>This should be viewed in contrast to the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes">powerset</a>
which would generate repeated values:</p>
<pre><code>    powerset([1,1,1,2,2,3]) --&gt; [
        (),
        (1,), (1,), (1,),
        (2,), (2,),
        (3,),
        (1, 1), (1, 1), (1, 1),
        (1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2),
        (1, 3), (1, 3), (1, 3),
        ... cut for brevity ...
        (1, 1, 1, 2, 2), (1, 1, 1, 2, 3), (1, 1, 1, 2, 3),
        (1, 1, 2, 2, 3), (1, 1, 2, 2, 3), (1, 1, 2, 2, 3)
    ] # 63 records.
</code></pre>
<p>As the number of duplicate values grow, the number of redundant options
grows exponentially if using powerset.
In the example above the powerset generates 63 vs the 23 unique options
generated in the unique_powerset.</p>
<p>The assertion <code>set(powerset(iterable)) == unique_powerset(iterable)</code> must
always be true, and whilst the former method is available, powerset of
any iterables longer than 20 items, become intolerable except for the most
patient programmers.</p>
<p>The trick is therefore the generate the unique powerset without having to filter 
the duplicates. This calls for some combinatorial tricks, but explaining these 
without the context they're applied in, would be rather pointless.</p>
<p>So without further ado, this is the full code:</p>
<pre><code>from itertools import combinations


def unique_powerset(iterable):
    # first we summarize the iterable into blocks of identical values. Example:
    # [1,1,1,2,2,3] --&gt;
    # d = {
    #     1: [[1],[1,1],[1,1,1]],
    #     2: [[2],[2,2]],
    #     3: [[3]]
    #     }
    d = {i: iterable.count(i) for i in set(iterable)}
    blocks = {i: [] for i in set(iterable)}
    for k, v in d.items():
        for i in range(1, v + 1):
            blocks[k].append([k] * i)

    # Next we generate the powersets of the unique values only:
    for r in range(1, len(blocks) + 1):
        for clusters in combinations(blocks, r):
            # each 'cluster' is now an element from the powerset of the
            # unique elements --&gt; (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)

            # first we set indices for the accessing the first element in
            # the clusters values:
            c_index = [0 for _ in clusters]
            # this allows us to increment each index in values of each block.
            # Hereby c_index = [0,1,0] on the cluster (1,2,3) becomes [1,2,2,3].

            # next we set the upper limit to control the incremental iteration
            c_limit = [len(blocks[i]) for i in clusters]

            while not all(a == b for a, b in zip(c_index, c_limit)):
                # harvest combination
                result = []
                for idx, grp in enumerate(clusters):  # (1,2,3)
                    values = blocks[grp]  # v = 1:[[1],[1,1]. [1,1,1]]
                    value_idx = c_index[idx]  # [0,0,0]
                    value = values[value_idx]
                    result.extend(value)
                yield tuple(result)

                # update the indices:
                reset_idx = None
                for i in range(len(clusters)):  # counter position.
                    if c_index[i] &lt; c_limit[i]:
                        c_index[i] += 1  # counter value

                    if c_index[i] == c_limit[i]:
                        reset_idx = i
                    else:
                        break

                # reset the preceding values in indices if the counter position
                # has incremented.
                if reset_idx is not None and reset_idx + 1 &lt; len(clusters):
                    for j in range(reset_idx + 1):
                        c_index[j] = 0
</code></pre>
<p>End.</p></body></html>